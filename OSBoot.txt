Computer Architecture and the Boot Process

-When we reboot our computer, it must start up again, initially without any notion of
an operating system.

-The pre-OS environment of your computer offers little in the way of rich services: at this stage even a simple file system would be a luxury (e.g.
read and write logical files to a disk), but we have none of that. Luckily, what we do have is the Basic Input/Output Software (BIOS), a collection of software routines that are initially loaded from a chip into memory and initialised when the computer is switched on. BIOS provides auto-detection and basic control of your computer’s essential devices, such as the screen, keyboard, and hard disks.
(BIOS is firmware used to perform hardware initialization during the booting process (power-on startup), and to provide runtime services for operating systems and programs. The BIOS firmware comes pre-installed on a personal computer's system board, and it is the first software to run when powered  on.)

-Since BIOS has no notion of File-System in itself, we cannot load an operating system directly. Thus we go to the "boot sector" of the physical memory disk(i.e. Cylinder 0, Head 0, Sector 0) which is basically the easiest place to go to as no FS is available.

-Since some of our disks may
not contain an operating systems (they may simply be connected for additional storage),
then it is important that BIOS can determine whether the boot sector of a particular
disk is boot code that is intended for execution or simply data.

-Again, an unsophisticated means is adopted here by BIOS, whereby the last two
bytes of an intended boot sector must be set to the magic number 0xaa55. So, BIOS
loops through each storage device (e.g. floppy drive, hard disk, CD drive, etc.), reads
the boot sector into memory, and instructs the CPU to begin executing the first boot
sector it finds that ends with the magic number.

BIOS, Boot Blocks, and the Magic Number
-If we use a binary editor, such as TextPad [?] or GHex [?], that will let us write raw byte
values to a file, then we can craft ourselves a simple yet valid boot sector.

e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa

A machine code boot sector, with each byte displayed in hexadecimal.

• The initial three bytes, in hexadecimal as 0xe9, 0xfd and 0xff, are actually
machine code instructions, as defined by the CPU manufacturer, to perform an
endless jump.
• The last two bytes, 0x55 and 0xaa, make up the magic number, which tells BIOS
that this is indeed a boot block and not just data that happens to be on a drive’s
boot sector.
• The file is padded with zeros (’*’ indicates zeros omitted for brevity), basically to
position the magic BIOS number at the end of the 512 byte disk sector.


Note- the x86 architecture handles multi-byte values in little-endian format, whereby less significant bytes proceed
more significant bytes, which is contrary to our familiar numbering system. Thus we see magic BIOS
number was earlier described as the 16-bit value 0xaa55 but in our boot sector was
written as the consecutive bytes 0x55 and 0xaa.

-This is possibly the smallest program your computer could run, but it is a valid
program nonetheless, and we can test this in two ways, the second of which is much safer
and better suited to our kind of experiments:
• Using whatever means your current operating system will allow, write this boot
block to the first sector of a non-essential storage device (e.g. floppy disk or flash
drive), then reboot the computer.
• Use virtual machine software, such as VMWare or VirtualBox, and set the boot
block code as a disk image of a virtual machine, then start-up the virtual machine.

-You can be sure this code has been loaded and executed if your computer simply
hangs after booting, without a message such as “No operating system found”.

Note - Without the infinite loop in beginning of the machine code, CPU
would tear off, executing every subsequent instruction in memory, most of which will
be random, uninitialised bytes.

CPU EMULATORS:
Bochs: A x86 CPU Emulator
QEmu : Can run other architectures than x86 too

